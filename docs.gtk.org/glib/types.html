<!--
SPDX-FileCopyrightText: GLib Development Team

SPDX-License-Identifier: LGPL-2.1-or-later
--><!DOCTYPE html><html lang="en"><!-- Mirrored from docs.gtk.org/glib/types.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 24 Nov 2024 14:17:19 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->

  <title>GLib – 2.0: Basic Types</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta charset="utf-8">

  
  <meta property="og:type" content="website">

  

  
  <meta property="og:title" content="GLib: Basic Types">
  <meta property="og:description" content="Reference for GLib-2.0: Basic Types">
  <meta name="twitter:title" content="GLib: Basic Types">
  <meta name="twitter:description" content="Reference for GLib-2.0: Basic Types">


  
  <meta name="twitter:card" content="summary">

  
  
  
  <link rel="search" type="application/opensearchdescription+xml" title="GLib" href="opensearch.xml">
  
  

  <link rel="stylesheet" href="style.css" type="text/css">

  

  
  <script src="urlmap.js"></script>
  
  
  <script src="fzy.js"></script>
  <script src="search.js"></script>
  
  <script src="main.js"></script>

  
</head>

<body>
  <div id="body-wrapper" tabindex="-1">

    

    <button id="btn-to-top" class="hidden"><span class="up-arrow"></span></button>

    
<section id="main" class="content">
  
  <h4 id="title" style="display:flex;">
    Basic Types
    <a href="#title" class="anchor"></a>
    
  </h4>
  
  <section>
    <div class="docblock">
    <h1 id="basic-types">Basic Types<a class="md-anchor" href="#basic-types" title="Permanent link"></a></h1>
<p>GLib defines a number of commonly used types, which can be divided
into several&nbsp;groups:</p>
<ul>
<li>New types which are not part of standard C (but are defined in
   various C standard library header files) — <a href="#gboolean"><code>gboolean</code></a>,
   <a href="#gssize"><code>gssize</code></a>.</li>
<li>Integer types which are guaranteed to be the same size across
   all platforms — <a href="#gint8"><code>gint8</code></a>, <a href="#guint8"><code>guint8</code></a>, <a href="#gint16"><code>gint16</code></a>,
   <a href="#guint16"><code>guint16</code></a>, <a href="#gint32"><code>gint32</code></a>, <a href="#guint32"><code>guint32</code></a>,
   <a href="#gint64"><code>gint64</code></a>, <a href="#guint64"><code>guint64</code></a>.</li>
<li>Types which are easier to use than their standard C counterparts —
   <a href="#gpointer"><code>gpointer</code></a>, <a href="#gconstpointer"><code>gconstpointer</code></a>,
   <a href="#guchar"><code>guchar</code></a>, <a href="#guint"><code>guint</code></a>, <a href="#gushort"><code>gushort</code></a>,
   <a href="#gulong"><code>gulong</code></a>.</li>
<li>Types which correspond exactly to standard C types, but are
   included for completeness — <a href="#gchar"><code>gchar</code></a>, <a href="#gint"><code>gint</code></a>,
   <a href="#gshort"><code>gshort</code></a>, <a href="#glong"><code>glong</code></a>, <a href="#gfloat"><code>gfloat</code></a>,
   <a href="#gdouble"><code>gdouble</code></a>.</li>
<li>Types which correspond exactly to standard C99 types, but are available
   to use even if your compiler does not support C99 — <a href="#gsize"><code>gsize</code></a>,
   <a href="#goffset"><code>goffset</code></a>, <a href="#gintptr"><code>gintptr</code></a>, <a href="#guintptr"><code>guintptr</code></a>.</li>
</ul>
<p>GLib also defines macros for the limits of some of the standard
integer and floating point types, as well as macros for suitable
<a href="man:printf(3)"><code>printf()</code></a> formats for these&nbsp;types.</p>
<p>Note that depending on the platform and build configuration, the format
macros might not be compatible with the system provided
<a href="man:printf(3)"><code>printf()</code></a> function, because GLib might use a different
<code>printf()</code> implementation internally. The format macros will always work with
GLib <span class="caps">API</span> (like <a href="func.print.html"><code>g_print()</code></a>), and with any C99 compatible <code>printf()</code>
implementation.</p>
<h2 id="basic-types_1">Basic Types<a class="md-anchor" href="#basic-types_1" title="Permanent link"></a></h2>
<h3 id="gboolean"><code>gboolean</code><a class="md-anchor" href="#gboolean" title="Permanent link"></a></h3>
<p>A standard boolean type. Variables of this type should only contain the value
<code>TRUE</code> or <code>FALSE</code>.</p>
<p>Never directly compare the contents of a <code>gboolean</code> variable with the values
<code>TRUE</code> or <code>FALSE</code>. Use <code>if (condition)</code> to check a <code>gboolean</code> is ‘true’, instead
of <code>if (condition == TRUE)</code>. Likewise use <code>if (!condition)</code> to check a
<code>gboolean</code> is&nbsp;‘false’.</p>
<p>There is no validation when assigning to a <code>gboolean</code> variable and so it could
contain any value represented by a <code>gint</code>. This is why the use of <code>if
(condition)</code> is recommended. All non-zero values in C evaluate to&nbsp;‘true’.</p>
<h3 id="gpointer"><code>gpointer</code><a class="md-anchor" href="#gpointer" title="Permanent link"></a></h3>
<p>An untyped pointer, exactly equivalent to <code>void *</code>.</p>
<p>The standard C <code>void *</code> type should usually be preferred in
new code, but <code>gpointer</code> can be used in contexts where a type name
must be a single word, such as in the <code>GType</code> name of
<code>G_TYPE_POINTER</code> or when generating a family of function names for
multiple types using&nbsp;macros.</p>
<h3 id="gconstpointer"><code>gconstpointer</code><a class="md-anchor" href="#gconstpointer" title="Permanent link"></a></h3>
<p>An untyped pointer to constant data, exactly equivalent to <code>const void *</code>.</p>
<p>The data pointed to should not be&nbsp;changed.</p>
<p>This is typically used in function prototypes to indicate
that the data pointed to will not be altered by the&nbsp;function.</p>
<p>The standard C <code>const void *</code> type should usually be preferred in
new code, but <code>gconstpointer</code> can be used in contexts where a type name
must be a single&nbsp;word.</p>
<h3 id="gchar"><code>gchar</code><a class="md-anchor" href="#gchar" title="Permanent link"></a></h3>
<p>Equivalent to the standard C <code>char</code> type.</p>
<p>This type only exists for symmetry with <code>guchar</code>.
The standard C <code>char</code> type should be preferred in new&nbsp;code.</p>
<h3 id="guchar"><code>guchar</code><a class="md-anchor" href="#guchar" title="Permanent link"></a></h3>
<p>Equivalent to the standard C <code>unsigned char</code> type.</p>
<p>The standard C <code>unsigned char</code> type should usually be preferred in
new code, but <code>guchar</code> can be used in contexts where a type name
must be a single word, such as in the <code>GType</code> name of
<code>G_TYPE_UCHAR</code> or when generating a family of function names for
multiple types using&nbsp;macros.</p>
<h2 id="naturally-sized-integers">Naturally Sized Integers<a class="md-anchor" href="#naturally-sized-integers" title="Permanent link"></a></h2>
<h3 id="gint"><code>gint</code><a class="md-anchor" href="#gint" title="Permanent link"></a></h3>
<p>Equivalent to the standard C <code>int</code> type.</p>
<p>Values of this type can range from <code>INT_MIN</code> to <code>INT_MAX</code>,
or equivalently from <code>G_MININT</code> to <code>G_MAXINT</code>.</p>
<p>This type only exists for symmetry with <a href="#guint"><code>guint</code></a>.
The standard C <code>int</code> type should be preferred in new&nbsp;code.</p>
<dl>
<dt><code>G_MININT</code></dt>
<dd>
<p>The minimum value which can be held in a <code>gint</code>.</p>
<p>This is the same as standard C <code>INT_MIN</code>, which is available since C99
and should be preferred in new&nbsp;code.</p>
</dd>
<dt><code>G_MAXINT</code></dt>
<dd>
<p>The maximum value which can be held in a <code>gint</code>.</p>
<p>This is the same as standard C <code>INT_MAX</code>, which is available since C99
and should be preferred in new&nbsp;code.</p>
</dd>
</dl>
<h3 id="guint"><code>guint</code><a class="md-anchor" href="#guint" title="Permanent link"></a></h3>
<p>Equivalent to the standard C <code>unsigned int</code> type.</p>
<p>Values of this type can range from <code>0</code> to <code>UINT_MAX</code>,
or equivalently <code>0</code> to <code>G_MAXUINT</code>.</p>
<p>The standard C <code>unsigned int</code> type should usually be preferred in
new code, but <code>guint</code> can be used in contexts where a type name
must be a single word, such as in the <code>GType</code> name of
<code>G_TYPE_UINT</code> or when generating a family of function names for
multiple types using&nbsp;macros.</p>
<dl>
<dt><code>G_MAXUINT</code></dt>
<dd>
<p>The maximum value which can be held in a <code>guint</code>.</p>
<p>This is the same as standard C <code>UINT_MAX</code>, which is available since C99
and should be preferred in new&nbsp;code.</p>
</dd>
</dl>
<h3 id="gshort"><code>gshort</code><a class="md-anchor" href="#gshort" title="Permanent link"></a></h3>
<p>Equivalent to the standard C <code>short</code> type.</p>
<p>Values of this type can range from <code>SHRT_MIN</code> to <code>SHRT_MAX</code>,
or equivalently <code>G_MINSHORT</code> to <code>G_MAXSHORT</code>.</p>
<p>This type only exists for symmetry with <code>gushort</code>.
The standard C <code>short</code> type should be preferred in new&nbsp;code.</p>
<dl>
<dt><code>G_MINSHORT</code></dt>
<dd>
<p>The minimum value which can be held in a <code>gshort</code>.</p>
<p>This is the same as standard C <code>SHRT_MIN</code>, which is available since C99
and should be preferred in new&nbsp;code.</p>
</dd>
<dt><code>G_MAXSHORT</code></dt>
<dd>
<p>The maximum value which can be held in a <code>gshort</code>.</p>
<p>This is the same as standard C <code>SHRT_MAX</code>, which is available since C99
and should be preferred in new&nbsp;code.</p>
</dd>
</dl>
<h3 id="gushort"><code>gushort</code><a class="md-anchor" href="#gushort" title="Permanent link"></a></h3>
<p>Equivalent to the standard C <code>unsigned short</code> type.</p>
<p>Values of this type can range from <code>0</code> to <code>USHRT_MAX</code>,
or equivalently from <code>0</code> to <code>G_MAXUSHORT</code>.</p>
<p>The standard C <code>unsigned short</code> type should usually be preferred in
new code, but <code>gushort</code> can be used in contexts where a type name
must be a single word, such as when generating a family of function
names for multiple types using&nbsp;macros.</p>
<dl>
<dt><code>G_MAXUSHORT</code></dt>
<dd>
<p>The maximum value which can be held in a <code>gushort</code>.</p>
<p>This is the same as standard C <code>USHRT_MAX</code>, which is available since C99
and should be preferred in new&nbsp;code.</p>
</dd>
</dl>
<h3 id="glong"><code>glong</code><a class="md-anchor" href="#glong" title="Permanent link"></a></h3>
<p>Equivalent to the standard C <code>long</code> type.</p>
<p>Values of this type can range from <code>LONG_MIN</code> to <code>LONG_MAX</code>,
or equivalently <code>G_MINLONG</code> to <code>G_MAXLONG</code>.</p>
<p>This type only exists for symmetry with <code>gulong</code>.
The standard C <code>long</code> type should be preferred in new&nbsp;code.</p>
<dl>
<dt><code>G_MINLONG</code></dt>
<dd>
<p>The minimum value which can be held in a <code>glong</code>.</p>
<p>This is the same as standard C <code>LONG_MIN</code>, which is available since C99
and should be preferred in new&nbsp;code.</p>
</dd>
<dt><code>G_MAXLONG</code></dt>
<dd>
<p>The maximum value which can be held in a <code>glong</code>.</p>
<p>This is the same as standard C <code>ULONG_MAX</code>, which is available since C99
and should be preferred in new&nbsp;code.</p>
</dd>
</dl>
<h3 id="gulong"><code>gulong</code><a class="md-anchor" href="#gulong" title="Permanent link"></a></h3>
<p>Equivalent to the standard C <code>unsigned long</code> type.</p>
<p>Values of this type can range from <code>0</code> to <code>G_MAXULONG</code>.</p>
<p>The standard C <code>unsigned long</code> type should usually be preferred in
new code, but <code>gulong</code> can be used in contexts where a type name
must be a single word, such as in the <code>GType</code> name of
<code>G_TYPE_ULONG</code> or when generating a family of function names for
multiple types using&nbsp;macros.</p>
<dl>
<dt><code>G_MAXULONG</code></dt>
<dd>
<p>The maximum value which can be held in a <code>gulong</code>.</p>
<p>This is the same as standard C <code>ULONG_MAX</code>, which is available since C99
and should be preferred in new&nbsp;code.</p>
</dd>
</dl>
<h2 id="fixed-width-integers">Fixed Width Integers<a class="md-anchor" href="#fixed-width-integers" title="Permanent link"></a></h2>
<h3 id="gint8"><code>gint8</code><a class="md-anchor" href="#gint8" title="Permanent link"></a></h3>
<p>A signed integer guaranteed to be 8 bits on all platforms,
similar to the standard C <code>int8_t</code>.</p>
<p>The <code>int8_t</code> type should be preferred in new code, unless
consistency with pre-existing APIs requires use of <code>gint8</code>
(see <a href="#gsize"><code>gsize</code></a> for more&nbsp;details).</p>
<p>Values of this type can range from <code>G_MININT8</code> (= -128) to
<code>G_MAXINT8</code> (=&nbsp;127).</p>
<dl>
<dt><code>G_MININT8</code></dt>
<dd>
<p>The minimum value which can be held in a <code>gint8</code>.</p>
<p>Since:&nbsp;2.4</p>
</dd>
<dt><code>G_MAXINT8</code></dt>
<dd>
<p>The maximum value which can be held in a <code>gint8</code>.</p>
<p>This is the same as standard C <code>INT8_MAX</code>, which should be
preferred in new&nbsp;code.</p>
<p>Since:&nbsp;2.4</p>
</dd>
</dl>
<h3 id="guint8"><code>guint8</code><a class="md-anchor" href="#guint8" title="Permanent link"></a></h3>
<p>An unsigned integer guaranteed to be 8 bits on all platforms,
similar to the standard C <code>uint8_t</code>.</p>
<p>The <code>uint8_t</code> type should be preferred in new code, unless
consistency with pre-existing APIs requires use of <code>guint8</code>
(see <a href="#gsize"><code>gsize</code></a> for more&nbsp;details).</p>
<p>Values of this type can range from <code>0</code> to <code>G_MAXUINT8</code> (=&nbsp;255).</p>
<dl>
<dt><code>G_MAXUINT8</code></dt>
<dd>
<p>The maximum value which can be held in a <code>guint8</code>.</p>
<p>This is the same as standard C <code>UINT8_MAX</code>, which should be
preferred in new&nbsp;code.</p>
<p>Since:&nbsp;2.4</p>
</dd>
</dl>
<h3 id="gint16"><code>gint16</code><a class="md-anchor" href="#gint16" title="Permanent link"></a></h3>
<p>A signed integer guaranteed to be 16 bits on all platforms,
similar to the standard C <code>int16_t</code>.</p>
<p>The <code>int16_t</code> type should be preferred in new code, unless
consistency with pre-existing APIs requires use of <code>gint16</code>
(see <a href="#gsize"><code>gsize</code></a> for more&nbsp;details).</p>
<p>Values of this type can range from <code>G_MININT16</code> (= -32,768) to
<code>G_MAXINT16</code> (=&nbsp;32,767).</p>
<p>To print or scan values of this type, use
<code>G_GINT16_MODIFIER</code> and/or <code>G_GINT16_FORMAT</code>.</p>
<dl>
<dt><code>G_MININT16</code></dt>
<dd>
<p>The minimum value which can be held in a <code>gint16</code>.</p>
<p>Since:&nbsp;2.4</p>
</dd>
<dt><code>G_MAXINT16</code></dt>
<dd>
<p>The maximum value which can be held in a <code>gint16</code>.</p>
<p>This is the same as standard C <code>INT16_MAX</code>, which should be
preferred in new&nbsp;code.</p>
<p>Since:&nbsp;2.4</p>
</dd>
<dt><code>G_GINT16_MODIFIER</code></dt>
<dd>
<p>The platform dependent length modifier for conversion specifiers
for scanning and printing values of type <code>gint16</code> or <code>guint16</code>. It
is a string literal, but doesn’t include the percent-sign, such
that you can add precision and length modifiers between percent-sign
and conversion specifier and append a conversion&nbsp;specifier.</p>
<p>The following example prints <code>0x7b</code>;
<code>c
gint16 value = 123;
g_print ("%#" G_GINT16_MODIFIER "x", value);</code></p>
<p>This is not necessarily the correct modifier for printing and scanning
<code>int16_t</code> values, even though the in-memory representation is the same.
Standard C macros like <code>PRId16</code> and <code>SCNd16</code> should be used for <code>int16_t</code>.</p>
<p>Since:&nbsp;2.4</p>
</dd>
<dt><code>G_GINT16_FORMAT</code></dt>
<dd>
<p>This is the platform dependent conversion specifier for scanning and
printing values of type <code>gint16</code>. It is a string literal, but doesn’t
include the percent-sign, such that you can add precision and length
modifiers between percent-sign and conversion&nbsp;specifier.</p>
<p><code>c
gint16 in;
gint32 out;
sscanf ("42", "%" G_GINT16_FORMAT, &amp;in)
out = in * 1000;
g_print ("%" G_GINT32_FORMAT, out);</code></p>
<p>This is not necessarily the correct format for printing and scanning
<code>int16_t</code> values, even though the in-memory representation is the same.
Standard C macros like <code>PRId16</code> and <code>SCNd16</code> should be used for <code>int16_t</code>.</p>
</dd>
</dl>
<h3 id="guint16"><code>guint16</code><a class="md-anchor" href="#guint16" title="Permanent link"></a></h3>
<p>An unsigned integer guaranteed to be 16 bits on all platforms,
similar to the standard C <code>uint16_t</code>.</p>
<p>The <code>uint16_t</code> type should be preferred in new code, unless
consistency with pre-existing APIs requires use of <code>guint16</code>
(see <a href="#gsize"><code>gsize</code></a> for more&nbsp;details).</p>
<p>Values of this type can range from <code>0</code> to <code>G_MAXUINT16</code> (=&nbsp;65,535).</p>
<p>To print or scan values of this type, use
<code>G_GINT16_MODIFIER</code> and/or <code>G_GUINT16_FORMAT</code>.</p>
<dl>
<dt><code>G_MAXUINT16</code></dt>
<dd>
<p>The maximum value which can be held in a <code>guint16</code>.</p>
<p>This is the same as standard C <code>UINT16_MAX</code>, which should be
preferred in new&nbsp;code.</p>
<p>Since:&nbsp;2.4</p>
</dd>
<dt><code>G_GUINT16_FORMAT</code></dt>
<dd>
<p>This is the platform dependent conversion specifier for scanning
and printing values of type <code>guint16</code>. See also <code>G_GINT16_FORMAT</code></p>
<p>This is not necessarily the correct modifier for printing and scanning
<code>uint16_t</code> values, even though the in-memory representation is the same.
Standard C macros like <code>PRIu16</code> and <code>SCNu16</code> should be used for <code>uint16_t</code>.</p>
</dd>
</dl>
<h3 id="gint32"><code>gint32</code><a class="md-anchor" href="#gint32" title="Permanent link"></a></h3>
<p>A signed integer guaranteed to be 32 bits on all&nbsp;platforms.</p>
<p>The <code>int32_t</code> type should be preferred in new code, unless
consistency with pre-existing APIs requires use of <code>gint16</code>
(see <a href="#gsize"><code>gsize</code></a> for more&nbsp;details).</p>
<p>Values of this type can range from <code>G_MININT32</code> (= -2,147,483,648)
to <code>G_MAXINT32</code> (=&nbsp;2,147,483,647).</p>
<p>To print or scan values of this type, use
<code>G_GINT32_MODIFIER</code> and/or <code>G_GINT32_FORMAT</code>.</p>
<p>Note that on platforms with more than one 32-bit standard integer type,
<code>gint32</code> and <code>int32_t</code> are not necessarily implemented by the same
32-bit integer type.
For example, on an <span class="caps">ILP32</span> platform where <code>int</code> and <code>long</code> are both 32-bit,
it might be the case that one of these types is <code>int</code> and the other
is <code>long</code>.
See <a href="#gsize"><code>gsize</code></a> for more details of what this&nbsp;implies.</p>
<dl>
<dt><code>G_MININT32</code></dt>
<dd>
<p>The minimum value which can be held in a <code>gint32</code>.</p>
<p>Since:&nbsp;2.4</p>
</dd>
<dt><code>G_MAXINT32</code></dt>
<dd>
<p>The maximum value which can be held in a <code>gint32</code>.</p>
<p>This is the same as standard C <code>INT32_MAX</code>, which should be
preferred in new&nbsp;code.</p>
<p>Since:&nbsp;2.4</p>
</dd>
<dt><code>G_GINT32_MODIFIER</code></dt>
<dd>
<p>The platform dependent length modifier for conversion specifiers
for scanning and printing values of type <code>gint32</code> or <code>guint32</code>. It
is a string literal. See also <code>G_GINT16_MODIFIER</code>.</p>
<p>This is not necessarily the correct modifier for printing and scanning
<code>int32_t</code> values, even though the in-memory representation is the same.
Standard C macros like <code>PRId32</code> and <code>SCNd32</code> should be used for <code>int32_t</code>.</p>
<p>Since:&nbsp;2.4</p>
</dd>
<dt><code>G_GINT32_FORMAT</code></dt>
<dd>
<p>This is the platform dependent conversion specifier for scanning
and printing values of type <code>gint32</code>. See also <code>G_GINT16_FORMAT</code>.</p>
<p>This is not necessarily the correct modifier for printing and scanning
<code>int32_t</code> values, even though the in-memory representation is the same.
Standard C macros like <code>PRId32</code> and <code>SCNd32</code> should be used for <code>int32_t</code>.</p>
</dd>
</dl>
<h3 id="guint32"><code>guint32</code><a class="md-anchor" href="#guint32" title="Permanent link"></a></h3>
<p>An unsigned integer guaranteed to be 32 bits on all platforms,
similar to the standard C <code>uint32_t</code>.</p>
<p>The <code>uint32_t</code> type should be preferred in new code, unless
consistency with pre-existing APIs requires use of <code>guint32</code>
(see <a href="#gsize"><code>gsize</code></a> for more&nbsp;details).</p>
<p>Values of this type can range from <code>0</code> to <code>G_MAXUINT32</code> (=&nbsp;4,294,967,295).</p>
<p>To print or scan values of this type, use
<code>G_GINT32_MODIFIER</code> and/or <code>G_GUINT32_FORMAT</code>.</p>
<p>Note that on platforms with more than one 32-bit standard integer type,
<code>guint32</code> and <code>uint32_t</code> are not necessarily implemented by the same
32-bit integer type.
See <a href="#gsize"><code>gsize</code></a> for more details of what this&nbsp;implies.</p>
<dl>
<dt><code>G_MAXUINT32</code></dt>
<dd>
<p>The maximum value which can be held in a <code>guint32</code>.</p>
<p>This is the same as standard C <code>UINT32_MAX</code>, which should be
preferred in new&nbsp;code.</p>
<p>Since:&nbsp;2.4</p>
</dd>
<dt><code>G_GUINT32_FORMAT</code></dt>
<dd>
<p>This is the platform dependent conversion specifier for scanning
and printing values of type <code>guint32</code>. See also <code>G_GINT16_FORMAT</code>.</p>
<p>This is not necessarily the correct modifier for printing and scanning
<code>uint32_t</code> values, even though the in-memory representation is the same.
Standard C macros like <code>PRIu32</code> and <code>SCNu32</code> should be used for <code>uint32_t</code>.</p>
</dd>
</dl>
<h3 id="gint64"><code>gint64</code><a class="md-anchor" href="#gint64" title="Permanent link"></a></h3>
<p>A signed integer guaranteed to be 64 bits on all platforms,
similar to the standard C <code>int64_t</code>.</p>
<p>The <code>int64_t</code> type should be preferred in new code, unless
consistency with pre-existing APIs requires use of <code>gint64</code>
(see <a href="#gsize"><code>gsize</code></a> for more&nbsp;details).</p>
<p>Values of this type can range from <code>G_MININT64</code>
(= -9,223,372,036,854,775,808) to <code>G_MAXINT64</code>
(=&nbsp;9,223,372,036,854,775,807).</p>
<p>To print or scan values of this type, use
<code>G_GINT64_MODIFIER</code> and/or <code>G_GINT64_FORMAT</code>.</p>
<p>Note that on platforms with more than one 64-bit standard integer type,
<code>gint64</code> and <code>int64_t</code> are not necessarily implemented by the same
64-bit integer type.
For example, on a platform where both <code>long</code> and <code>long long</code> are 64-bit,
it might be the case that one of those types is used for <code>gint64</code>
and the other is used for <code>int64_t</code>.
See <a href="#gsize"><code>gsize</code></a> for more details of what this&nbsp;implies.</p>
<dl>
<dt><code>G_MININT64</code></dt>
<dd>The minimum value which can be held in a <code>gint64</code>.</dd>
<dt><code>G_MAXINT64</code></dt>
<dd>The maximum value which can be held in a <code>gint64</code>.</dd>
<dt><code>G_GINT64_MODIFIER</code></dt>
<dd>
<p>The platform dependent length modifier for conversion specifiers
for scanning and printing values of type <code>gint64</code> or <code>guint64</code>.
It is a string&nbsp;literal.</p>
<p>Some platforms do not support printing 64-bit integers, even
though the types are supported. On such platforms <code>G_GINT64_MODIFIER</code>
is not&nbsp;defined.</p>
<p>This is not necessarily the correct modifier for printing and scanning
<code>int64_t</code> values, even though the in-memory representation is the same.
Standard C macros like <code>PRId64</code> and <code>SCNd64</code> should be used for <code>int64_t</code>.</p>
<p>Since:&nbsp;2.4</p>
</dd>
<dt><code>G_GINT64_FORMAT</code></dt>
<dd>
<p>This is the platform dependent conversion specifier for scanning
and printing values of type <code>gint64</code>. See also <code>G_GINT16_FORMAT</code>.</p>
<p>Some platforms do not support scanning and printing 64-bit integers,
even though the types are supported. On such platforms <code>G_GINT64_FORMAT</code>
is not defined. Note that <a href="man:scanf(3)"><code>scanf()</code></a> may not support 64-bit
integers, even if <code>G_GINT64_FORMAT</code> is defined. Due to its weak error
handling, <code>scanf()</code> is not recommended for parsing anyway; consider using
<a href="func.ascii_strtoull.html"><code>g_ascii_strtoull()</code></a>&nbsp;instead.</p>
<p>This is not necessarily the correct format for printing and scanning
<code>int64_t</code> values, even though the in-memory representation is the same.
Standard C macros like <code>PRId64</code> and <code>SCNd64</code> should be used for <code>int64_t</code>.</p>
</dd>
<dt><code>G_GINT64_CONSTANT(val)</code></dt>
<dd>
<p>This macro is used to insert 64-bit integer literals
into the source&nbsp;code.</p>
<p>It is similar to the standard C <code>INT64_C</code> macro,
which should be preferred in new&nbsp;code.</p>
</dd>
</dl>
<h3 id="guint64"><code>guint64</code><a class="md-anchor" href="#guint64" title="Permanent link"></a></h3>
<p>An unsigned integer guaranteed to be 64-bits on all platforms,
similar to the standard C <code>uint64_t</code> type.</p>
<p>The <code>uint64_t</code> type should be preferred in new code, unless
consistency with pre-existing APIs requires use of <code>guint64</code>
(see <a href="#gsize"><code>gsize</code></a> for more&nbsp;details).</p>
<p>Values of this type can range from <code>0</code> to <code>G_MAXUINT64</code>
(=&nbsp;18,446,744,073,709,551,615).</p>
<p>To print or scan values of this type, use
<code>G_GINT64_MODIFIER</code> and/or <code>G_GUINT64_FORMAT</code>.</p>
<p>Note that on platforms with more than one 64-bit standard integer type,
<code>guint64</code> and <code>uint64_t</code> are not necessarily implemented by the same
64-bit integer type.
See <a href="#gsize"><code>gsize</code></a> for more details of what this&nbsp;implies.</p>
<dl>
<dt><code>G_MAXUINT64</code></dt>
<dd>
<p>The maximum value which can be held in a <code>guint64</code>.</p>
<p>This is the same as standard C <code>UINT64_MAX</code>, which should be
preferred in new&nbsp;code.</p>
</dd>
<dt><code>G_GUINT64_FORMAT</code></dt>
<dd>
<p>This is the platform dependent conversion specifier for scanning
and printing values of type <code>guint64</code>. See also <code>G_GINT16_FORMAT</code>.</p>
<p>Some platforms do not support scanning and printing 64-bit integers,
even though the types are supported. On such platforms <code>G_GUINT64_FORMAT</code>
is not defined.  Note that <a href="man:scanf(3)"><code>scanf()</code></a> may not support 64-bit
integers, even if <code>G_GINT64_FORMAT</code> is defined. Due to its weak error
handling, <code>scanf()</code> is not recommended for parsing anyway; consider using
<a href="func.ascii_strtoull.html"><code>g_ascii_strtoull()</code></a>&nbsp;instead.</p>
<p>This is not necessarily the correct modifier for printing and scanning
<code>uint64_t</code> values, even though the in-memory representation is the same.
Standard C macros like <code>PRIu64</code> and <code>SCNu64</code> should be used for <code>uint64_t</code>.</p>
</dd>
<dt><code>G_GUINT64_CONSTANT(val)</code></dt>
<dd>
<p>This macro is used to insert 64-bit unsigned integer
literals into the source&nbsp;code.</p>
<p>It is similar to the standard C <code>UINT64_C</code> macro,
which should be preferred in new&nbsp;code.</p>
<p>Since:&nbsp;2.10</p>
</dd>
</dl>
<h2 id="floating-point">Floating Point<a class="md-anchor" href="#floating-point" title="Permanent link"></a></h2>
<h3 id="gfloat"><code>gfloat</code><a class="md-anchor" href="#gfloat" title="Permanent link"></a></h3>
<p>Equivalent to the standard C <code>float</code> type.</p>
<p>Values of this type can range from <code>-FLT_MAX</code> to <code>FLT_MAX</code>,
or equivalently from <code>-G_MAXFLOAT</code> to <code>G_MAXFLOAT</code>.</p>
<dl>
<dt><code>G_MINFLOAT</code></dt>
<dd>
<p>The minimum positive value which can be held in a <code>gfloat</code>.</p>
<p>If you are interested in the smallest value which can be held
in a <code>gfloat</code>, use <code>-G_MAXFLOAT</code>.</p>
<p>This is the same as standard C <code>FLT_MIN</code>, which is available since C99
and should be preferred in new&nbsp;code.</p>
</dd>
<dt><code>G_MAXFLOAT</code></dt>
<dd>
<p>The maximum value which can be held in a <code>gfloat</code>.</p>
<p>This is the same as standard C <code>FLT_MAX</code>, which is available since C99
and should be preferred in new&nbsp;code.</p>
</dd>
</dl>
<h3 id="gdouble"><code>gdouble</code><a class="md-anchor" href="#gdouble" title="Permanent link"></a></h3>
<p>Equivalent to the standard C <code>double</code> type.</p>
<p>Values of this type can range from <code>-DBL_MAX</code> to <code>DBL_MAX</code>,
or equivalently from <code>-G_MAXDOUBLE</code> to <code>G_MAXDOUBLE</code>.</p>
<dl>
<dt><code>G_MINDOUBLE</code></dt>
<dd>
<p>The minimum positive value which can be held in a <code>gdouble</code>.</p>
<p>If you are interested in the smallest value which can be held
in a <code>gdouble</code>, use <code>-G_MAXDOUBLE</code>.</p>
<p>This is the same as standard C <code>DBL_MIN</code>, which is available since C99
and should be preferred in new&nbsp;code.</p>
</dd>
<dt><code>G_MAXDOUBLE</code></dt>
<dd>
<p>The maximum value which can be held in a <code>gdouble</code>.</p>
<p>This is the same as standard C <code>DBL_MAX</code>, which is available since C99
and should be preferred in new&nbsp;code.</p>
</dd>
</dl>
<h2 id="architecture-sized-integers">Architecture Sized Integers<a class="md-anchor" href="#architecture-sized-integers" title="Permanent link"></a></h2>
<h3 id="gsize"><code>gsize</code><a class="md-anchor" href="#gsize" title="Permanent link"></a></h3>
<p>An unsigned integer type of the result of the <code>sizeof</code> operator,
corresponding to the <code>size_t</code> type defined in&nbsp;C99.</p>
<p>The standard <code>size_t</code> type should be preferred in new code, unless
consistency with pre-existing APIs requires <code>gsize</code>
(see below for more&nbsp;details).</p>
<p><code>gsize</code> is usually 32 bit wide on a 32-bit platform and 64 bit wide
on a 64-bit platform. Values of this type can range from <code>0</code> to
<code>G_MAXSIZE</code>.</p>
<p>This type is wide enough to hold the size of the largest possible
memory allocation, but is not guaranteed to be wide enough to hold
the numeric value of a pointer: on platforms that use tagged pointers,
such as <a href="https://cheri-cpu.org/"><span class="caps">CHERI</span></a>, pointers can be numerically
larger than the size of the address space.
If the numeric value of a pointer needs to be stored in an integer
without information loss, use the standard C types <code>intptr_t</code> or
<code>uintptr_t</code>, or the similar GLib types <a href="#gintptr"><code>gintptr</code></a> or
<a href="#guintptr"><code>guintptr</code></a>.</p>
<p>To print or scan values of this type, use
<code>G_GSIZE_MODIFIER</code> and/or <code>G_GSIZE_FORMAT</code>.</p>
<p>Note that on platforms where more than one standard integer type is
the same size, <code>size_t</code> and <code>gsize</code> are always the same size but are
not necessarily implemented by the same standard integer type.
For example, on an <span class="caps">ILP32</span> platform where <code>int</code>, <code>long</code> and pointers
are all 32-bit, <code>size_t</code> might be <code>unsigned long</code> while <code>gsize</code>
might be <code>unsigned int</code>.
This can result in compiler warnings or unexpected C++ name-mangling
if the two types are used&nbsp;inconsistently.</p>
<p>As a result, changing a type from <code>gsize</code> to <code>size_t</code> in existing APIs
might be an incompatible <span class="caps">API</span> or <span class="caps">ABI</span> change, especially if C++
is involved. The safe option is to leave existing APIs using the same type
that they have historically used, and only use the standard C types in
new&nbsp;APIs.</p>
<p>Similar considerations apply to all the fixed-size types
(<a href="#gint8"><code>gint8</code></a>, <a href="#guint8"><code>guint8</code></a>, <a href="#gint16"><code>gint16</code></a>,
<a href="#guint16"><code>guint16</code></a>, <a href="#gint32"><code>gint32</code></a>, <a href="#guint32"><code>guint32</code></a>,
<a href="#gint64"><code>gint64</code></a>, <a href="#guint64"><code>guint64</code></a> and <a href="#goffset"><code>goffset</code></a>), as well
as <a href="#gintptr"><code>gintptr</code></a> and <a href="#guintptr"><code>guintptr</code></a>.
Types that are 32 bits or larger are particularly likely to be
affected by&nbsp;this.</p>
<dl>
<dt><code>G_MAXSIZE</code></dt>
<dd>
<p>The maximum value which can be held in a <code>gsize</code>.</p>
<p>This is the same as standard C <code>SIZE_MAX</code> (available since C99),
which should be preferred in new&nbsp;code.</p>
<p>Since:&nbsp;2.4</p>
</dd>
<dt><code>G_GSIZE_MODIFIER</code></dt>
<dd>
<p>The platform dependent length modifier for conversion specifiers
for scanning and printing values of type <code>gsize</code>. It
is a string&nbsp;literal.</p>
<p>Note that this is not necessarily the correct modifier to scan or
print a <code>size_t</code>, even though the in-memory representation is the
same. The Standard C <code>"z"</code> modifier should be used for <code>size_t</code>,
assuming a C99-compliant <code>printf</code> implementation is&nbsp;available.</p>
<p>Since:&nbsp;2.6</p>
</dd>
<dt><code>G_GSIZE_FORMAT</code></dt>
<dd>
<p>This is the platform dependent conversion specifier for scanning
and printing values of type <code>gsize</code>. See also <code>G_GINT16_FORMAT</code>.</p>
<p>Note that this is not necessarily the correct format to scan or
print a <code>size_t</code>, even though the in-memory representation is the
same. The standard C <code>"zu"</code> format should be used for <code>size_t</code>,
assuming a C99-compliant <code>printf</code> implementation is&nbsp;available.</p>
<p>Since:&nbsp;2.6</p>
</dd>
</dl>
<h3 id="gssize"><code>gssize</code><a class="md-anchor" href="#gssize" title="Permanent link"></a></h3>
<p>A signed variant of <a href="#gsize"><code>gsize</code></a>, corresponding to the
<code>ssize_t</code> defined in <span class="caps">POSIX</span> or the similar <code>SSIZE_T</code> in&nbsp;Windows.</p>
<p>In new platform-specific code, consider using <code>ssize_t</code> or <code>SSIZE_T</code>
directly.</p>
<p>Values of this type can range from <code>G_MINSSIZE</code> to <code>G_MAXSSIZE</code>.</p>
<p>Note that on platforms where <code>ssize_t</code> is implemented, <code>ssize_t</code> and
<code>gssize</code> might be implemented by different standard integer types
of the same size. Similarly, on Windows, <code>SSIZE_T</code> and <code>gssize</code>
might be implemented by different standard integer types of the same
size. See <a href="#gsize"><code>gsize</code></a> for more&nbsp;details.</p>
<p>This type is also not guaranteed to be the same as standard C
<code>ptrdiff_t</code>, although they are the same on many&nbsp;platforms.</p>
<p>To print or scan values of this type, use
<code>G_GSSIZE_MODIFIER</code> and/or <code>G_GSSIZE_FORMAT</code>.</p>
<dl>
<dt><code>G_MINSSIZE</code></dt>
<dd>
<p>The minimum value which can be held in a <code>gssize</code>.</p>
<p>Since:&nbsp;2.14</p>
</dd>
<dt><code>G_MAXSSIZE</code></dt>
<dd>
<p>The maximum value which can be held in a <code>gssize</code>.</p>
<p>Since:&nbsp;2.14</p>
</dd>
<dt><code>G_GSSIZE_FORMAT</code></dt>
<dd>
<p>This is the platform dependent conversion specifier for scanning
and printing values of type <code>gssize</code>. See also <code>G_GINT16_FORMAT</code>.</p>
<p>Note that this is not necessarily the correct format to scan or print
a <span class="caps">POSIX</span> <code>ssize_t</code> or a Windows <code>SSIZE_T</code>, even though the in-memory
representation is the same.
On <span class="caps">POSIX</span> platforms, the <code>"zd"</code> format should be used for <code>ssize_t</code>.</p>
<p>Since:&nbsp;2.6</p>
</dd>
<dt><code>G_GSSIZE_MODIFIER</code></dt>
<dd>
<p>The platform dependent length modifier for conversion specifiers
for scanning and printing values of type <code>gssize</code>. It
is a string&nbsp;literal.</p>
<p>Note that this is not necessarily the correct modifier to scan or print
a <span class="caps">POSIX</span> <code>ssize_t</code> or a Windows <code>SSIZE_T</code>, even though the in-memory
representation is the same.
On <span class="caps">POSIX</span> platforms, the <code>"z"</code> modifier should be used for <code>ssize_t</code>.</p>
<p>Since:&nbsp;2.6</p>
</dd>
</dl>
<h3 id="goffset"><code>goffset</code><a class="md-anchor" href="#goffset" title="Permanent link"></a></h3>
<p>A signed integer type that is used for file offsets,
corresponding to the <span class="caps">POSIX</span> type <code>off_t</code> as if compiling with
<code>_FILE_OFFSET_BITS</code> set to 64. <code>goffset</code> is always 64 bits wide, even on
32-bit architectures, and even if <code>off_t</code> is only 32 bits.
Values of this type can range from <code>G_MINOFFSET</code> to
<code>G_MAXOFFSET</code>.</p>
<p>To print or scan values of this type, use
<code>G_GOFFSET_MODIFIER</code> and/or <code>G_GOFFSET_FORMAT</code>.</p>
<p>On platforms with more than one 64-bit standard integer type,
even if <code>off_t</code> is also 64 bits in size, <code>goffset</code> and <code>off_t</code> are not
necessarily implemented by the same 64-bit integer type.
See <a href="#gsize"><code>gsize</code></a> for more details of what this&nbsp;implies.</p>
<p>Since:&nbsp;2.14</p>
<dl>
<dt><code>G_MINOFFSET</code></dt>
<dd>The minimum value which can be held in a <code>goffset</code>.</dd>
<dt><code>G_MAXOFFSET</code></dt>
<dd>The maximum value which can be held in a <code>goffset</code>.</dd>
<dt><code>G_GOFFSET_MODIFIER</code></dt>
<dd>
<p>The platform dependent length modifier for conversion specifiers
for scanning and printing values of type <code>goffset</code>. It is a string
literal. See also <code>G_GINT64_MODIFIER</code>.</p>
<p>This modifier should only be used with <code>goffset</code> values, and not
with <code>off_t</code>, which is not necessarily the same type or even the same&nbsp;size.</p>
<p>Since:&nbsp;2.20</p>
</dd>
<dt><code>G_GOFFSET_FORMAT</code></dt>
<dd>
<p>This is the platform dependent conversion specifier for scanning
and printing values of type <code>goffset</code>. See also <code>G_GINT64_FORMAT</code>.</p>
<p>This format should only be used with <code>goffset</code> values, and not
with <code>off_t</code>, which is not necessarily the same type or even the same&nbsp;size.</p>
<p>Since:&nbsp;2.20</p>
</dd>
<dt><code>G_GOFFSET_CONSTANT(val)</code></dt>
<dd>
<p>This macro is used to insert <code>goffset</code> 64-bit integer literals
into the source&nbsp;code.</p>
<p>See also <code>G_GINT64_CONSTANT()</code>.</p>
<p>Since:&nbsp;2.20</p>
</dd>
</dl>
<h3 id="gintptr"><code>gintptr</code><a class="md-anchor" href="#gintptr" title="Permanent link"></a></h3>
<p>Corresponds to the C99 type <code>intptr_t</code>,
a signed integer type that can hold any&nbsp;pointer.</p>
<p>The standard <code>intptr_t</code> type should be preferred in new code, unless
consistency with pre-existing APIs requires <code>gintptr</code>.
Note that <code>intptr_t</code> and <code>gintptr</code> might be implemented by different
standard integer types of the same size. See <a href="#gsize"><code>gsize</code></a> for more&nbsp;details.</p>
<p><code>gintptr</code> is not guaranteed to be the same type or the same size as
<a href="#gssize"><code>gssize</code></a>, even though they are the same on many <span class="caps">CPU</span>&nbsp;architectures.</p>
<p>To print or scan values of this type, use
<code>G_GINTPTR_MODIFIER</code> and/or <code>G_GINTPTR_FORMAT</code>.</p>
<p>Since:&nbsp;2.18</p>
<dl>
<dt><code>G_GINTPTR_MODIFIER</code></dt>
<dd>
<p>The platform dependent length modifier for conversion specifiers
for scanning and printing values of type <code>gintptr</code> or <code>guintptr</code>.
It is a string&nbsp;literal.</p>
<p>Note that this is not necessarily the correct modifier to scan or
print an <code>intptr_t</code>, even though the in-memory representation is the
same.
Standard C macros like <code>PRIdPTR</code> and <code>SCNdPTR</code> should be used for
<code>intptr_t</code>.</p>
<p>Since:&nbsp;2.22</p>
</dd>
<dt><code>G_GINTPTR_FORMAT</code></dt>
<dd>
<p>This is the platform dependent conversion specifier for scanning
and printing values of type <code>gintptr</code>.</p>
<p>Note that this is not necessarily the correct format to scan or
print an <code>intptr_t</code>, even though the in-memory representation is the
same.
Standard C macros like <code>PRIdPTR</code> and <code>SCNdPTR</code> should be used for
<code>intptr_t</code>.</p>
<p>Since:&nbsp;2.22</p>
</dd>
</dl>
<h3 id="guintptr"><code>guintptr</code><a class="md-anchor" href="#guintptr" title="Permanent link"></a></h3>
<p>Corresponds to the C99 type <code>uintptr_t</code>,
an unsigned integer type that can hold any&nbsp;pointer.</p>
<p>The standard <code>uintptr_t</code> type should be preferred in new code, unless
consistency with pre-existing APIs requires <code>guintptr</code>.
Note that <code>uintptr_t</code> and <code>guintptr</code> might be implemented by different
standard integer types of the same size. See <a href="#gsize"><code>gsize</code></a> for more&nbsp;details.</p>
<p><code>guintptr</code> is not guaranteed to be the same type or the same size as
<a href="#gsize"><code>gsize</code></a>, even though they are the same on many <span class="caps">CPU</span>&nbsp;architectures.</p>
<p>To print or scan values of this type, use
<code>G_GINTPTR_MODIFIER</code> and/or <code>G_GUINTPTR_FORMAT</code>.</p>
<p>Since:&nbsp;2.18</p>
<dl>
<dt><code>G_GUINTPTR_FORMAT</code></dt>
<dd>
<p>This is the platform dependent conversion specifier
for scanning and printing values of type <code>guintptr</code>.</p>
<p>Note that this is not necessarily the correct format to scan or
print a <code>uintptr_t</code>, even though the in-memory representation is the
same.
Standard C macros like <code>PRIuPTR</code> and <code>SCNuPTR</code> should be used for
<code>uintptr_t</code>.</p>
<p>Since:&nbsp;2.22</p>
</dd>
</dl>
    </div>
  </section>
</section>


    
<div id="toc" class="toc">
  <nav aria-labelledby="toc-title">
    <p id="toc-title">Content</p>
    <ul class="toc-list">
      
        
        <li class="toc-list-item"><a href="#basic-types_1"><span class="link-text">Basic Types</span></a></li>
        
        <li class="toc-list-item"><a href="#naturally-sized-integers"><span class="link-text">Naturally Sized Integers</span></a></li>
        
        <li class="toc-list-item"><a href="#fixed-width-integers"><span class="link-text">Fixed Width Integers</span></a></li>
        
        <li class="toc-list-item"><a href="#floating-point"><span class="link-text">Floating Point</span></a></li>
        
        <li class="toc-list-item"><a href="#architecture-sized-integers"><span class="link-text">Architecture Sized Integers</span></a></li>
        
      
    </ul>
  </nav>
</div>


    <section id="search" class="content hidden"></section>

    <footer>
    
    </footer>
  </div>



</body><!-- Mirrored from docs.gtk.org/glib/types.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 24 Nov 2024 14:17:19 GMT --></html>